lmrot[,1,N]<-lmks[,1,N]-cent[1]
lmrot[,2,N]<-lmks[,2,N]-cent[2]
for (s in 2:n) {
rot<-array(c(cos(symm[s]),-sin(symm[s]),sin(symm[s]),cos(symm[s])),dim=c(2,2)) # rotate ccw
lmrot[(hom*(s-1)+1):(hom*s),,N]<-t(apply(lmrot[(hom*(s-1)+1):(hom*s),,N],1,"%*%",rot))
}
points(lmrot[1:16,,1],col="yellow",pch=20)
points(lmrot[17:32,],col="green",pch=20)
points(lmrot[17:32,,],col="green",pch=20)
cent<-apply(lmks[,,N],2,mean,na.rm=T)
lmrot[,1,N]<-lmks[,1,N]-cent[1]
lmrot[,2,N]<-lmks[,2,N]-cent[2]
s<-2
rot<-array(c(cos(symm[s]),-sin(symm[s]),sin(symm[s]),cos(symm[s])),dim=c(2,2)) # rotate ccw
lmrot[(hom*(s-1)+1):(hom*s),,N]<-t(apply(lmrot[(hom*(s-1)+1):(hom*s),,N],1,"%*%",rot))
plot(rbind(lmks[,,1],lmrot[,,1]),type="n")
points(lmks[,,1])
lmcent<-cbind(lmks[,1,1]-cent[1],lmks[,2,1]-cent[2])
points(lmcent)
points(lmrot[17:32,,],col="green",pch=20)
lmrot[,1,N]<-lmks[,1,N]-cent[1]
lmrot[,2,N]<-lmks[,2,N]-cent[2]
lmrot[(hom*(s-1)+1):(hom*s),,N]
t(apply(lmrot[(hom*(s-1)+1):(hom*s),,N],1,"%*%",rot))
test
lmrot[(hom*(s-1)+1):(hom*s),,N]<-t(apply(lmrot[(hom*(s-1)+1):(hom*s),,N],1,"%*%",rot))
lmrot[,,1]
points(lmrot[17:32,,],col="blue",pch=20)
points(test,pch=20)
lmrot[17:32,,1]
test
lmrot[17:32,,1]==test
points(t(lmrot[17:32,,]),col="blue",pch=20)
lmrot[17:32,,]
lmrot[17:32,,1]
points(t(lmrot[17:32,,1]),col="blue",pch=20)
plot(rbind(lmks[,,1],lmrot[,,1]),type="n")
points(lmks[,,1])
lmcent<-cbind(lmks[,1,1]-cent[1],lmks[,2,1]-cent[2])
points(lmcent)
points(t(lmrot[17:32,,1]),col="blue",pch=20)
points(lmrot[17:32,1,1],lmrot[17:32,2,1],col="blue",pch=20)
for (s in 2:n) {
rot<-array(c(cos(symm[s]),-sin(symm[s]),sin(symm[s]),cos(symm[s])),dim=c(2,2)) # rotate ccw
lmrot[(hom*(s-1)+1):(hom*s),,N]<-t(apply(lmrot[(hom*(s-1)+1):(hom*s),,N],1,"%*%",rot))
}
points(lmrot[17:32,1,1],lmrot[17:32,2,1],col="green",pch=20)
lmrot[,1,N]<-lmks[,1,N]-cent[1]
lmrot[,2,N]<-lmks[,2,N]-cent[2]
for (s in 2:n) {
rot<-array(c(cos(symm[s]),-sin(symm[s]),sin(symm[s]),cos(symm[s])),dim=c(2,2)) # rotate ccw
lmrot[(hom*(s-1)+1):(hom*s),,N]<-t(apply(lmrot[(hom*(s-1)+1):(hom*s),,N],1,"%*%",rot))
}
plot(rbind(lmks[,,1],lmrot[,,1]),type="n")
points(lmks[,,1])
points(lmcent)
points(lmrot[1:16,,1],col="yellow",pch=20)
plot(rbind(lmks[,,1],lmcent),type="n")
points(lmks[,,1])
points(lmcent)
points(lmks[1:16,,1],col="yellow",pch=20)
points(lmks[17:32,,1],col="green",pch=20)
points(lmrot[1:16,,1],col="yellow",pch=20)
points(lmrot[17:32,1,1],lmrot[17:32,2,1],col="green",pch=20)
points(lmcent[17:32,],col="green",pch=20)
points(lmcent[33:48,],col="blue",pch=20)
points(lmrot[33:48,1,1],lmrot[33:48,2,1],col="blue",pch=20)
lmsets<-array(dim=c(hom,n,2,nspec))
x<-array(1:nlmk,dim=c(hom,n))
for (N in 1:nspec) {
for (j in 1:hom) {
lmsets[j,,,N]<-cbind(lmrot[x[j,],,N])
}
}
lmsets[,,,1]
lmsets[,,1,1]
lmsets[,,,1]
lmsets[1,,,1]
lmsets[2,,,1]
x
rot.m<-array(c(cos(pi/n),-sin(pi/n),sin(pi/n),cos(pi/n)),dim=c(2,2)) # half a sector
p.L<-which(!1:min(m)%in%c(b,m))
p.R<-which(!1:(nlmk/n)%in%c(b,m,p.L))
rot.m
p.L
p.R
theta<-array(dim=nspec)
for (N in 1:nspec){ # subsets of each specimen are of dimension [some homologous sets,2n,2].
b.sets<-array(dim=c(n*length(b),2))
for (i in 1:length(b)){
b.sets[((i-1)*n+1):(i*n),]<-lmsets[b,,,N][i,,]}
m.sets<-array(dim=c(n*length(m),2))
for (i in 1:length(m)){
m.sets[((i-1)*n+1):(i*n),]<-t(apply(lmsets[m,,,N][i,,],1,FUN="%*%",rot.m))} # rotate m.sets by half a sector
p.avg<-array(dim=c(length(p.L),n,2))
for (i in 1:n){ # average left and right paired landmarks
p.avg[,i,]<-rbind(apply(rbind(lmsets[p.L,i,1,N],lmsets[p.R,i,1,N]),2,mean,na.rm=T),apply(rbind(lmsets[p.L,i,2,N],lmsets[p.R,i,2,N]),2,mean,na.rm=T))
}
p.sets<-array(dim=c(n*length(p.L),2))
for (i in 1:length(p.L)){
p.sets[((i-1)*n+1):(i*n),]<-t(apply(p.avg[i,,],1,FUN="%*%",rot.m))} # resulting averaged landmarks will be on midline so rotate by half a sector
allsets<-rbind(b.sets,m.sets,p.sets) # all landmarks compressed into a line
axis<-lm(allsets[,2]~allsets[,1]-1) # lm of that line (through origin)
theta[N]<-atan(axis$coefficients) # angle of the first axis of reflection with respect to basis
}
theta
b.sets<-array(dim=c(n*length(b),2))
for (i in 1:length(b)){
b.sets[((i-1)*n+1):(i*n),]<-lmsets[b,,,N][i,,]}
m.sets<-array(dim=c(n*length(m),2))
for (i in 1:length(m)){
m.sets[((i-1)*n+1):(i*n),]<-t(apply(lmsets[m,,,N][i,,],1,FUN="%*%",rot.m))} # rotate m.sets by half a sector
p.avg<-array(dim=c(length(p.L),n,2))
for (i in 1:n){ # average left and right paired landmarks
p.avg[,i,]<-rbind(apply(rbind(lmsets[p.L,i,1,N],lmsets[p.R,i,1,N]),2,mean,na.rm=T),apply(rbind(lmsets[p.L,i,2,N],lmsets[p.R,i,2,N]),2,mean,na.rm=T))
}
p.sets<-array(dim=c(n*length(p.L),2))
for (i in 1:length(p.L)){
p.sets[((i-1)*n+1):(i*n),]<-t(apply(p.avg[i,,],1,FUN="%*%",rot.m))} # resulting averaged landmarks will be on midline so rotate by half a sector
allsets<-rbind(b.sets,m.sets,p.sets) # all landmarks compressed into a line
axis<-lm(allsets[,2]~allsets[,1]-1) # lm of that line (through origin)
theta[N]<-atan(axis$coefficients) # angle of the first axis of reflection with respect to basis
b.sets
N<-1
b.sets<-array(dim=c(n*length(b),2))
for (i in 1:length(b)){
b.sets[((i-1)*n+1):(i*n),]<-lmsets[b,,,N][i,,]}
m.sets<-array(dim=c(n*length(m),2))
for (i in 1:length(m)){
m.sets[((i-1)*n+1):(i*n),]<-t(apply(lmsets[m,,,N][i,,],1,FUN="%*%",rot.m))} # rotate m.sets by half a sector
p.avg<-array(dim=c(length(p.L),n,2))
for (i in 1:n){ # average left and right paired landmarks
p.avg[,i,]<-rbind(apply(rbind(lmsets[p.L,i,1,N],lmsets[p.R,i,1,N]),2,mean,na.rm=T),apply(rbind(lmsets[p.L,i,2,N],lmsets[p.R,i,2,N]),2,mean,na.rm=T))
}
p.sets<-array(dim=c(n*length(p.L),2))
for (i in 1:length(p.L)){
p.sets[((i-1)*n+1):(i*n),]<-t(apply(p.avg[i,,],1,FUN="%*%",rot.m))} # resulting averaged landmarks will be on midline so rotate by half a sector
allsets<-rbind(b.sets,m.sets,p.sets) # all landmarks compressed into a line
axis<-lm(allsets[,2]~allsets[,1]-1) # lm of that line (through origin)
theta[N]<-atan(axis$coefficients) # angle of the first axis of reflection with respect to basis
b.sets
plot(rbind(lmks[,,1],lmcent),type="n")
points(lmks[,,1])
points(lmcent)
points(b.sets)
plot(rbind(lmks[,,1],lmcent),type="n")
points(lmks[,,1])
points(lmcent)
points(b.sets,pch=20)
lmsets[1,,,1]
plot(rbind(lmks[,,1],lmcent),type="n")
points(lmks[,,1])
points(lmcent)
points(lmsets[1,,,1],pch=20)
points(lmcent[x[1,]],pch=20,col="red")
x[1,]
points(lmcent[x[1,],],pch=20,col="red")
plot(rbind(lmks[,,1],lmcent),type="n")
points(lmcent)
points(lmks[,,1])
points(lmcent[x[1,],],pch=20,col="red")
points(lmrot[x[1,],,1],pch=20,col="red")
plot(rbind(lmks[,,1],lmcent),type="n")
points(lmks[,,1])
points(lmcent)
points(lmrot[x[1,],,1],pch=20,col="red")
lmrot[x[1],,1]
lmrot[x[1,],,1]
lmrot[x[2,],,1]
lmrot[,,1]
symm[6]
for (i in 2:n){
symm[i]<-(i-1)*2*pi/n
}
symm
symm[6]
for (N in 1:nspec) {
cent<-apply(lmks[,,N],2,mean,na.rm=T)
lmrot[,1,N]<-lmks[,1,N]-cent[1]
lmrot[,2,N]<-lmks[,2,N]-cent[2]
for (s in 2:n) {
rot<-array(c(cos(symm[s]),-sin(symm[s]),sin(symm[s]),cos(symm[s])),dim=c(2,2)) # rotate ccw
lmrot[(hom*(s-1)+1):(hom*s),,N]<-t(apply(lmrot[(hom*(s-1)+1):(hom*s),,N],1,"%*%",rot))
}
}
lmrot[,,1]
points(lmrot[x[1,],,1],pch=20,col="red")
plot(rbind(lmks[,,1],lmcent),type="n")
points(lmks[,,1])
points(lmcent)
points(lmrot[x[1,],,1],pch=20,col="red")
points(lmrot[x[2,],,1],pch=20,col="blue")
for (N in 1:nspec) {
for (j in 1:hom) {
lmsets[j,,,N]<-cbind(lmrot[x[j,],,N])
}
}
lmsets
lmsets[,,,1]
lmsets[1,,,1]
lmrot[x[1,],,1]
theta<-array(dim=nspec)
theta<-array(dim=nspec)
b.sets<-array(dim=c(n*length(b),2))
for (i in 1:length(b)){
b.sets[((i-1)*n+1):(i*n),]<-lmsets[b,,,N][i,,]}
b.sets
N
N<-1
b.sets<-array(dim=c(n*length(b),2))
for (i in 1:length(b)){
b.sets[((i-1)*n+1):(i*n),]<-lmsets[b,,,N][i,,]}
b.sets
points(b.sets)
rot.m<-array(c(cos(pi/n),-sin(pi/n),sin(pi/n),cos(pi/n)),dim=c(2,2)) # half a sector
m.sets<-array(dim=c(n*length(m),2))
for (i in 1:length(m)){
m.sets[((i-1)*n+1):(i*n),]<-t(apply(lmsets[m,,,N][i,,],1,FUN="%*%",rot.m))} # rotate m.sets by half a sector
m.sets
points(m.sets,pch=20,col="green")
p.avg<-array(dim=c(length(p.L),n,2))
for (i in 1:n){ # average left and right paired landmarks
p.avg[,i,]<-rbind(apply(rbind(lmsets[p.L,i,1,N],lmsets[p.R,i,1,N]),2,mean,na.rm=T),apply(rbind(lmsets[p.L,i,2,N],lmsets[p.R,i,2,N]),2,mean,na.rm=T))
}
p.sets<-array(dim=c(n*length(p.L),2))
for (i in 1:length(p.L)){
p.sets[((i-1)*n+1):(i*n),]<-t(apply(p.avg[i,,],1,FUN="%*%",rot.m))} # resulting averaged landmarks will be on midline so rotate by half a sector
p.sets
points(p.sets,pch=20,col="grey")
p.agv
p.avg
?reverse
??reverse
p.R<-rev(which(!1:(nlmk/n)%in%c(b,m,p.L)))
p.R
p.avg<-array(dim=c(length(p.L),n,2))
for (i in 1:n){ # average left and right paired landmarks in each sector
p.avg[,i,]<-rbind(apply(rbind(lmsets[p.L,i,1,N],lmsets[p.R,i,1,N]),2,mean,na.rm=T),apply(rbind(lmsets[p.L,i,2,N],lmsets[p.R,i,2,N]),2,mean,na.rm=T))
}
p.sets<-array(dim=c(n*length(p.L),2))
for (i in 1:length(p.L)){
p.sets[((i-1)*n+1):(i*n),]<-t(apply(p.avg[i,,],1,FUN="%*%",rot.m))} 
points(p.sets,pch=20,col="grey")
plot(rbind(lmks[,,1],lmcent),type="n")
points(lmks[,,1])
points(lmcent)
points(b.sets,pch=20,col="blue")
points(m.sets,pch=20,col="red")
points(p.sets,pch=20,col="grey")
p.avg[1,1,]
lmcent[c(3,16),]
i<-1
lmsets[p.L,i,1,N]
lmsets[p.R,i,1,N]
lmcent[p.L,]
apply(rbind(lmsets[p.L,i,1,N],lmsets[p.R,i,1,N]),2,mean,na.rm=T)
rbind(apply(rbind(lmsets[p.L,i,1,N],lmsets[p.R,i,1,N]),2,mean,na.rm=T),apply(rbind(lmsets[p.L,i,2,N],lmsets[p.R,i,2,N]),2,mean,na.rm=T))
lmcent[p.R,]
t(rbind(apply(rbind(lmsets[p.L,i,1,N],lmsets[p.R,i,1,N]),2,mean,na.rm=T),apply(rbind(lmsets[p.L,i,2,N],lmsets[p.R,i,2,N]),2,mean,na.rm=T)))
test<-t(rbind(apply(rbind(lmsets[p.L,i,1,N],lmsets[p.R,i,1,N]),2,mean,na.rm=T),apply(rbind(lmsets[p.L,i,2,N],lmsets[p.R,i,2,N]),2,mean,na.rm=T)))
points(test)
i
N
points(test,col="grey",pch=20)
plot(rbind(lmks[,,1],lmcent),type="n")
points(lmks[,,1])
points(lmcent)
points(b.sets,pch=20,col="blue")
points(m.sets,pch=20,col="red")
points(test,col="grey",pch=20)
p.avg[,i,]
test
for (i in 1:n){ # average left and right paired landmarks in each sector
p.avg[,i,]<-t(rbind(apply(rbind(lmsets[p.L,i,1,N],lmsets[p.R,i,1,N]),2,mean,na.rm=T),apply(rbind(lmsets[p.L,i,2,N],lmsets[p.R,i,2,N]),2,mean,na.rm=T)))
}
p.avg[,1,]
p.sets<-array(dim=c(n*length(p.L),2))
for (i in 1:length(p.L)){
p.sets[((i-1)*n+1):(i*n),]<-t(apply(p.avg[i,,],1,FUN="%*%",rot.m))} # resulting averaged landmarks will be on midline so rotate by half a sector
points(p.sets,pch=20,col="grey")
plot(rbind(lmks[,,1],lmcent),type="n")
points(lmks[,,1])
points(lmcent)
points(b.sets,pch=20,col="blue")
points(m.sets,pch=20,col="red")
points(p.sets,pch=20,col="grey")
allsets<-rbind(b.sets,m.sets,p.sets) # all landmarks compressed into a line
axis<-lm(allsets[,2]~allsets[,1]-1) # lm of that line (through origin)
theta[N]<-atan(axis$coefficients)
theta[1]
theta[N]
points(allsets,col="green")
axis
N
theta[N]<-atan(axis$coefficients)
theta[N]
axis$coefficients
linethrough(c(0,0),c(1,axis$coefficients))
plot(lmcent)
points(b.sets,pch=20,col="blue")
points(m.sets,pch=20,col="red")
points(p.sets,pch=20,col="grey")
linethrough(c(0,0),c(1,axis$coefficients))
points(allsets,col="green")
points(lmcent[c(1,2),],pch=20)
p.avg[,,1]
dim(p.avg)
pfor (i in 1:length(p.L)){
for (i in 1:length(p.L)){
print(p.avg[i,,])}
N 
rot.b<-array(c(cos(pi/n),sin(pi/n),-sin(pi/n),cos(pi/n)),dim=c(2,2)) # half a sector
b.sets<-array(dim=c(n*length(b),2))
for (i in 1:length(b)){
b.sets[((i-1)*n+1):(i*n),]<-t(apply(lmsets[b,,,N][i,,],1,FUN="%*%",rot.b))}  # rotate b.sets by half a sector to place on midline
m.sets<-array(dim=c(n*length(m),2))
for (i in 1:length(m)){
m.sets[((i-1)*n+1):(i*n),]<-lmsets[m,,,N][i,,]} 
p.avg<-array(dim=c(length(p.L),n,2))
for (i in 1:n){ # average left and right paired landmarks in each sector
p.avg[,i,]<-t(rbind(apply(rbind(lmsets[p.L,i,1,N],lmsets[p.R,i,1,N]),2,mean,na.rm=T),apply(rbind(lmsets[p.L,i,2,N],lmsets[p.R,i,2,N]),2,mean,na.rm=T)))
}
p.sets<-array(dim=c(n*length(p.L),2))
for (i in 1:length(p.L)){
p.sets[((i-1)*n+1):(i*n),]<-p.avg[i,,]} # resulting averaged landmarks will be on midline
allsets<-rbind(b.sets,m.sets,p.sets) # all landmarks compressed into a line
axis<-lm(allsets[,2]~allsets[,1]-1) # lm of that line (through origin)
theta[N]<-atan(axis$coefficients) # angle of the first axis of reflection with respect to basis
plot(lmcent)
points(b.sets,pch=20,col="blue")
points(m.sets,pch=20,col="red")
points(p.sets,pch=20,col="grey")
points(allsets,col="green")
linethrough(c(0,0),c(1,axis$coefficients))
points(lmcent[c(7,8),],pch=20)
axis
lm(allsets[,2]~allsets[,1]-1)
tps.to.imp(lmks,"montastraea.txt")
tps.to.imp
data<-lmks
size<-rep(1,dim(data[3]))
dim(data)<-lmks
dim(data)
data<-na.omit(lmks)
size<-rep(1,dim(data[3]))
size<-rep(1,dim(data)[3])
size
rows<-dim(data)[3]
cols<-dim(data)[1]*2+1
result<-array(dim=c(rows,cols))
result[,1]<-size
for (i in 1:dim(data)[3]) {
lmks<-vector(mode="numeric")
for (j in 1:dim(data)[1]) {
lmks<-append(test,data[j,,i])
}
result[,2:cols]<-lmks
}
i
corals<-test.tps[[1]]
for (i in 1:4){
corals[which(corals[,1,i]<20&corals[,2,i]>480),,i]<-NA}
for (i in 1:dim(corals)[3]){
corals[,,i]<-corals[c(2:5,7:96,1,6),,i]}
corals<-test.tps[[1]]
for (i in 1:dim(corals)[3]){
corals[,,i]<-corals[c(2:5,7:96,1,6),,i]
corals[which(corals[,1,i]<20&corals[,2,i]>480),,i]<-NA}
data<-na.omit(corals)
dim(data)
data[,,1]
data<-corals
size<-rep(1,dim(data)[3])
size
rows<-dim(data)[3]
cols<-dim(data)[1]*2+1
result<-array(dim=c(rows,cols))
i
i<-1
lmks<-vector(mode="numeric")
for (j in 1:dim(data)[1]) {
lmks<-append(test,data[j,,i])
}
lmks
result[,2:cols]<-lmks
dim(result)
dim(lmks)
dim(result[,2:cols])
result
result[,2:cols]
lmks
dim(lmks)
i
lmks
lmks<-vector(mode="numeric")
for (j in 1:dim(data)[1]) {
lmks<-append(lmks,data[j,,i])
}
lmks
result[,2:cols]<-lmks
for (i in 1:dim(data)[3]) {
lmks<-vector(mode="numeric")
for (j in 1:dim(data)[1]) {
lmks<-append(lmks,data[j,,i])
}
result[,2:cols]<-lmks
}
result
data<-corals
size<-rep(1,dim(data)[3])
rows<-dim(data)[3]
cols<-dim(data)[1]*2+1
result<-array(dim=c(rows,cols))
result[,1]<-size
for (i in 1:dim(data)[3]) {
lmks<-vector(mode="numeric")
for (j in 1:dim(data)[1]) {
lmks<-append(lmks,data[j,,i])
}
result[,2:cols]<-lmks
}
result
dim(data)[1]
j<-1
data[j,,i]
i
i<-1
data[j,,i]
corals[,,1]
data[j,,i]
corals[1:16,,1]
for (j in 1:dim(data)[1]) {
print(append(lmks,data[j,,i])
}
for (j in 1:dim(data)[1]) {
print(append(lmks,data[j,,i]))}
corals[1:16,,1]
j<-1
i<-1
append(lmks,data[j,,i])
corals[,,1]
lmks<-vector(mode="numeric")
i
for (j in 1:dim(data)[1]) {
lmks<-print(data[j,,i])
}
lmks
lmks<-vector(mode="numeric")
for (j in 1:dim(data)[1]) {
lmks<-append(lmks,data[j,,i])
}
lmks
corals[1:24,,,1]
corals[1:24,,1]
lmks<-vector(mode="numeric")
for (j in 1:dim(data)[1]) {
lmks<-append(lmks,data[j,,i])
}
result[,2:cols]<-lmks
size<-rep(1,dim(data)[3])
rows<-dim(data)[3]
cols<-dim(data)[1]*2+1
result<-array(dim=c(rows,cols))
result[,1]<-size
for (i in 1:dim(data)[3]) {
lmks<-vector(mode="numeric")
for (j in 1:dim(data)[1]) {
lmks<-append(lmks,data[j,,i])
}
result[i,2:cols]<-lmks
}
result
source("sourcethis.R")
source("C:/Users/vjsyvers/Documents/R/sourcethis.R")
M<-tps.to.imp(corals)
tps.to.imp(corals,"montastraeaIMP.txt")
source("C:/Users/vjsyvers/Documents/R/sourcethis.R")
tps.to.imp(corals,target="montastraeaIMP.txt")
getwd()
M<-tps.to.imp(corals,target="montastraeaIMP.txt")
M<-tps.to.imp(corals)
M
eigenrotation<-function(N, M)
 {M<-as.matrix(M); N<-as.matrix(N)
 sN<-svd(var(N))$vectors
 k<-dim(N)[2]
 p<-dim(M)[1]
 Nn<-N%*%sN
 Mn<-M%*%sN
 uNn<-apply(Nn, 2, mean)
 Mnf<-Mn-rep(1,p)%*%t(uNn)
 Mnf}
dim(allsets)
n
P<-dim(allsets)[1]/n
for (N in 1:nspec){print(allsets[(P*(N-1)+1):P*N,])}
for (N in 1:nspec){print((P*(N-1)+1):P*N,)}
for (N in 1:nspec){print(P*(N-1)+1):(P*N))}
for (N in 1:nspec){print((P*(N-1)+1):(P*N))}
for (i in 1:n){print((P*(i-1)+1):(P*i))}
for (i in 1:n){print(allsets[(P*(i-1)+1):(P*i),])}
allsets
NMat<-array(dim=c(10,2,6))
for (i in 1:n){NMat[,,i]<-(allsets[(P*(i-1)+1):(P*i),])}
NMat
lmks
coral
corals[,,1]
class(corals[,,1])
class(test.tps[[1]])
dim(test.tps[[1]])
allsets
